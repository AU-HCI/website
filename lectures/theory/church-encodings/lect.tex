\documentclass{article}
\usepackage{parskip}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{color}
\usepackage{graphicx}
\usepackage{mathpartir}

\newtheorem{thm}{Theorem}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{corollary}[thm]{Corollary}
\newtheorem{definition}[thm]{Definition}
\newtheorem{remark}[thm]{Remark}
\newtheorem{proposition}[thm]{Proposition}
\newtheorem{notn}[thm]{Notation}
\newtheorem{observation}[thm]{Observation}

\newcommand {\redto}[0]{\rightsquigarrow}

\input{lam-ott}

\title{Functions are Data!!!\\Programming Languages (CSCI 3300)\vspace{-22px}}
\author{Prof. Harley Eades (heades@gru.edu).}
\date{\vspace{-22px}}
\begin{document}
\maketitle  

We have finally completed defining the $\lambda$-calculus.  It is both
simple, and powerful, well, at least I have been telling you that it
is powerful.  In this short note we are going to look at just how
powerful it really is by defining data types as functions.

The idea is to treat certain $\lambda$-expressions has having a
particular meaning -- like being a boolean or a number -- and then
assuming that meaning define operations on that data (function).  We
determine a $\lambda$-expressions meaning by its behavior.  That is,
if the function acts like a boolean, then we will call it a boolean.
This holds with my slogan that programs give data meaning.

Throughout this note we will define several $\lambda$-expressions and
to make this easier we will use a special syntax to give
$\lambda$-expressions names.  An example is the following \[
\mathsf{id} := [[\x.x]] \] The name on the left like $\mathsf{id}$ is
an alias of the expression on the right $[[\x.x]]$ and so we will
treat them as being identical.  It is important to note that the name
we give is not actually part of the $\lambda$-calculus, but is just
for connivence.

The datatype encodings given here are known collectively as Church
Encodings.  Named after Alonzo Church -- the inventor of the
$\lambda$-calculus.

\section{Functions are Booleans!}
\label{sec:functions_are_booleans!}

We have been using booleans quite a lot this semester so we are well
versed in their operations.  So what functions can we consider as
being true, false, and an if-expression?  We select the following for
the first two:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      \mathsf{True}  := [[\x.h(\y.x)]]\\
      \mathsf{False} := [[\x.h(\y.y)]]\\
    \end{array}
  \end{math}
\end{center}
You might be wondering why we would choose such a definition?  Well,
it is because using these we can define the if-expression:
\[ \mathsf{if} := [[\b.h(\x.h(\y.h(b x y)))]] \] The above
$\lambda$-expression first takes in a boolean -- well we are assuming
that it does -- $[[b]]$ and then any other terms $[[x]]$ and $[[y]]$
where $[[x]]$ is what happens if $[[b]]$ is true, and $[[y]]$ is what
happens if $[[b]]$ is false.  As we mentioned above we completely
choose these expressions based on their behavior.  Consider an
example:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      [[if True (\x.x) (\x.h(x x))]] 
      & = [[ul((\b.h(\x.h(\y.h(b x y)))) True) (\x.x) (\x.h(x x))]]\\
      & \redto [[ul((\x.h(\y.h(True x y))) (\x.x)) (\x.h(x x))]]\\
      & \redto [[ul((\y.h(True (\x.x) y)) (\x.h(x x)))]]\\
      & \redto [[True (\x.x) (\x.h(x x)) ]]\\
      & = [[ul((\x.\y.x) (\x.x)) (\x.h(x x)) ]]\\
      & \redto [[ul((\y. (\x.x)) (\x.h(x x))) ]]\\
      & \redto [[(\x.x)]]\\
    \end{array}
  \end{math}
\end{center}
So $[[if]]$ certainly acts like an if-expression when we give it
$[[True]]$, but what about $[[False]]$?
\begin{center}
  \begin{math}
    \begin{array}{lll}
      [[if False (\x.x) (\x.h(x x))]] 
      & = [[ul((\b.h(\x.h(\y.h(b x y)))) False) (\x.x) (\x.h(x x))]]\\
      & \redto [[ul((\x.h(\y.h(False x y))) (\x.x)) (\x.h(x x))]]\\
      & \redto [[ul((\y.h(False (\x.x) y)) (\x.h(x x)))]]\\
      & \redto [[False (\x.x) (\x.h(x x)) ]]\\
      & = [[ul((\x.\y.y) (\x.x)) (\x.h(x x)) ]]\\
      & \redto [[ul((\y.y) (\x.h(x x))) ]]\\
      & \redto [[(\x.h(x x))]]\\
    \end{array}
  \end{math}
\end{center}

If you look at the definition $[[if]]$ closely you will see that
really all it does is call the boolean.  Thus, it is the data
$[[True]]$ and $[[False]]$ that are really determining the behavior of
$[[if]]$.  This is the essence of these types of datatype encodings.
That is, they embody case analysis.

Now that we have the if-expression we can define any other boolean
operation we want.  For example:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      [[not]] = [[\b.h(if b False True)]]\\
      [[and]] = [[\b1.\b2.h(if b1 (if b2 True False) False)]]\\
      [[or]] = [[\b1.\b2.h(if b1 (if b2 True True) False)]]\\
    \end{array}
  \end{math}
\end{center}
Now these expressions get quite large:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      [[and]] 
      & = [[\b1.\b2.h( b1 (if b2 True False) False)]]\\
      & = [[\b1.\b2.h(ul((\b.h(\x.h(\y.h(b x y)))) b1) (if b2 True False) False)]]\\
      & \redto [[\b1.\b2.h(ul((\x.h(\y.h(b1 x y))) (if b2 True False)) False)]]\\
      & \redto [[\b1.\b2.h(ul((\y.h(b1 (if b2 True False) y)) False))]]\\
      & \redto [[\b1.\b2.h(b1 (if b2 True False) False)]]\\
      & = [[\b1.\b2.h(b1 (ul((\b.h(\x.h(\y.h(b x y)))) b2) True False) False)]]\\
      & \redto [[\b1.\b2.h(b1 (ul((\x.h(\y.h(b2 x y))) True) False) False)]]\\
      & \redto [[\b1.\b2.h(b1 (ul((\y.h(b2 True y)) False)) False)]]\\
      & \redto [[\b1.\b2.h(b1 (b2 True False) False)]]\\
      & = [[\b1.\b2.h(b1 (b2 (\x.\y.x) (\x.\y.y)) (\x.\y.y))]]\\
    \end{array}
  \end{math}
\end{center}

Note that these expressions behave like the booleans if and only if
they are given the booleans we have defined above as input. Now there
is nothing stopping someone from giving these expressions any term
they like.  After all, there are no types!  Now if something other
than a boolean is given, then the behavior of these expressions will
not be boolean-like.

Try out some other boolean expressions.  In fact, we have just
basically proven that the $\lambda$-calculus subsumes Iffy-Lang!  The
$\lambda$-calculus can do anything Iffy-Lang can do, and so much more.
% section functions_are_booleans! (end)

\section{Functions are Numbers}
\label{sec:functions_are_numbers}

We can encode arithmetic in a similar fashion to the booleans, but
first lets introduce a particular representation of arithmetic that
will make understanding the Church-encoded numbers easier.

\subsection{Peano Arithmetic}
\label{subsec:peano_arithmetic}
We can define all of the set of peano numbers, denoted $\mathbb{P}$, using the following rules:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      $$\mprset{flushleft}
    \inferrule* [right=Zero] {
      \,
    }{0 \in \mathbb{P}}
    &
    $$\mprset{flushleft}
    \inferrule* [right=Suc] {
      n \in \mathbb{P}
    }{(s\,n) \in \mathbb{P}}
    \end{array}
  \end{math}
\end{center}
We call the unary function $s$ the successor function, and it should
be thought of as taking in a natural number $n$ and then returning
$n+1$.  

A list of the first ten peano numbers:
\begin{center}
  \begin{math}
    \begin{array}{rll}
      0. & 0\\
      1. & s\,0\\
      2. & s\,s\,0\\
      3. & s\,s\,s\,0\\
      4. & s\,s\,s\,s\,0\\
      5. & s\,s\,s\,s\,s\,0\\
      6. & s\,s\,s\,s\,s\,s\,0\\
      7. & s\,s\,s\,s\,s\,s\,s\,0\\
      8. & s\,s\,s\,s\,s\,s\,s\,s\,0\\
      9. & s\,s\,s\,s\,s\,s\,s\,s\,s\,0\\
      10.& s\,s\,s\,s\,s\,s\,s\,s\,s\,s\,0\\
    \end{array}
  \end{math}
\end{center}
Therefore, a natural number $n \in \mathbb{N} = \{0,1,2,3,4,\ldots\}$
can be defined as the peano number $\hat{n} = s^n 0$ where $s^n\,0 =
\underbrace{s\,\cdots\,s}_{n}\,0$.

Peano numbers are a particular representation of the natural numbers,
in fact, they look a lot like a datatype.  So we better make sure we
can define the usual arithmetic operations.  First, we try and
understand how we might define addition.  

The addition operation on peano numbers is best described if we think
in a recursive fashion.  Suppose we want to add the numbers $\hat{3}$
and $\hat{4}$ to obtain $\hat{7}$.  How might we do this?  We can
start by noticing that:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      \hat{3} = s\,s\,s\,0 & \hat{4} = s\,s\,s\,s\,0\\
    \end{array}
  \end{math}
\end{center}
Now we want to obtain $\hat{7} = s\,s\,s\,s\,s\,s\,s\,0$, but notice that 
\[s\,s\,s\,s\,s\,s\,s\,0 = s\,s\,s\,(s\,s\,s\,s\,0) = s\,s\,s\,(s^4\,0) = s^3\,(s^4\,0) = s^{3+4}\,0\]

How might we do this recursively?  We can peal off a successor from
the first number and add it to the second:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      \hat{3} = s\,s\,s\,0 & \hat{4} = s\,s\,s\,s\,0\\
      \hat{2} = s\,s\,0    & \hat{5} = s\,s\,s\,s\,s\,0\\
      \hat{1} = s\,0       & \hat{6} = s\,s\,s\,s\,s\,s\,0\\
      \hat{0} = 0          & \hat{7} = s\,s\,s\,s\,s\,s\,s\,0\\
    \end{array}
  \end{math}
\end{center}
Then the final solution is on the right when we hit $0$ on the left.

This is well and good, but rather inefficient. It turns out that we
can do a little better.  Examining the above will reveal that if we have
a peano number like $\hat{4}$, then to add say $\hat{3}$ to it, we
really just need to replace the zero in $\hat{4}$ with $\hat{3}$.
Then we would obtain $\hat{7}$ in one fell swoop.  Using
$\lambda$-calculus notation if we could transform $\hat{4} =
s\,s\,s\,s\,0$ into the function $\lambda z.s\,s\,s\,s\,z$, then
$\hat{7} = (\lambda z.s\,s\,s\,s\,z)\,\hat{3}$.  In fact, this is
exactly how we will model addition in the $\lambda$-calculus.

How about multiplication? Instead of adding a single successor on the
right for every successor on the left, we make a copy of all
successors on the right, and add them to the number on the right for
every successor on the left.  The following is the step by step
process of multiplying $\hat{3}$ and $\hat{4}$:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      \hat{3} = s\,s\,s\,0 & \hat{4} = s\,s\,s\,s\,0\\
      \hat{2} = s\,s\,0    & \hat{8} = {\color{green}{s\,s\,s\,s}}\,s\,s\,s\,s\,0\\
      \hat{1} = s\,0       & \hat{12} = {\color{blue}{s\,s\,s\,s}}\,{\color{green}{s\,s\,s\,s}}\,s\,s\,s\,s\,0\\
    \end{array}
  \end{math}
\end{center}
Now our base case is one instead of zero.  We can see that:
\[\hat{12} = {\color{blue}{s\,s\,s\,s}}\,{\color{green}{s\,s\,s\,s}}\,s\,s\,s\,s\,0 = \hat{12} = s^4\,{\color{green}{s\,s\,s\,s}}\,s\,s\,s\,s\,0 =  s^4\,s^4\,s\,s\,s\,s\,0 = s^4\,s^4\,s^4\,0 = s^{4+4+4}\,0 = s^{3*4}\,0 \]
This implies that we can also define multiplication in terms of
addition.  We denote the addition we defined above as $[[plus]]$.  Now
using $\lambda$-calculus notation if we could transform $\hat{3} =
s\,s\,s\,0$ into the function $\lambda s.s\,s\,s\,0$, then we could
simply apply the latter to the function $\lambda n.[[plus]]\,4\,n$,
and we would obtain
\begin{center}
  \begin{math}
    \begin{array}{lll}
      \hat{12} 
      & = (\lambda s.s\,s\,\,s\,0)\,(\lambda n.[[plus]]\,4\,n) \\
      & \redto (\lambda n.[[plus]]\,4\,n) ((\lambda n.[[plus]]\,4\,n) ((\lambda n.[[plus]]\,4\,n) 0))\\
      & \redto (\lambda n.[[plus]]\,4\,n) ((\lambda n.[[plus]]\,4\,n) ([[plus]]\,4\,0)\\ 
      & \redto (\lambda n.[[plus]]\,4\,n) ([[plus]]\,4\,([[plus]]\,4\,0)) \\ 
      & \redto [[plus]]\,4\,([[plus]]\,4\,([[plus]]\,4\,0)) \\ 
    \end{array}
  \end{math}
\end{center}
This final definition is exactly how we will define multiplication in
the $\lambda$-calculus.

Now by combining the previous two patterns we can use multiplication
to define exponentiation.  As an example, consider how to compute
$\hat{2}^{\hat{3}}$.  If we could transform multiplication -- denoted
$[[mult]]$ -- into $\lambda n.[[mult]]\,\hat{2}\,n$, and transform $\hat{3}$
into the expression $\lambda s.\lambda z.s\,s\,s\,z$, then we could define
exponentiation as the following:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      \hat{8}
      & = (\lambda s.\lambda z.s\,s\,s\,z)\,(\lambda n.[[mult]]\,\hat{2}\,n)\,\hat{1} \\
      & \redto (\lambda z.(\lambda n.[[mult]]\,\hat{2}\,n)\,((\lambda n.[[mult]]\,\hat{2}\,n)\,((\lambda n.[[mult]]\,\hat{2}\,n)\,z)))\,\hat{1}\\
      & \redto (\lambda n.[[mult]]\,\hat{2}\,n)\,((\lambda n.[[mult]]\,\hat{2}\,n)\,((\lambda n.[[mult]]\,\hat{2}\,n)\,\hat{1})))\\
      & \redto (\lambda n.[[mult]]\,\hat{2}\,n)\,((\lambda n.[[mult]]\,\hat{2}\,n)\,([[mult]]\,\hat{2}\,\hat{1}))\\
      & \redto (\lambda n.[[mult]]\,\hat{2}\,n)\,([[mult]]\,\hat{2}\,([[mult]]\,\hat{2}\,\hat{1}))\\
      & \redto [[mult]]\,\hat{2}\,([[mult]]\,\hat{2}\,([[mult]]\,\hat{2}\,\hat{1}))\\
    \end{array}
  \end{math}
\end{center}
So in order to define exponentiation we had to not only abstract
either the zero or the successor function, but both!  This gives us
the final representation of peano numbers in the $\lambda$-calculus.
% subsection peano_arithmetic (end)

\subsection{Peano Numbers in the $\lambda$-Calculus}
\label{subsec:peano_numbers_in_the_lam-calculus}
We define the peano numbers in the $\lambda$-calculus as follows:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      \hat{0} := [[\s.\z.z]]\\
      \hat{1} := [[\s.\z.h(s z)]]\\
      \hat{2} := [[\s.\z.h(s (s z))]]\\
      \hat{3} := [[\s.\z.h(s (s (s z)))]]\\
      \hat{4} := [[\s.\z.h(s (s (s (s z))))]]\\
      \vdots \\
      \hat{n} := \lambda s.\lambda z.s^n\,z
    \end{array}
  \end{math}
\end{center}
Now we can define addition using the same principle as the previous section:
\[ [[plus]] := [[\n1.\n2.(\s.\z.h(n2 s (n1 s z)))]] \] Remember, just
as we saw for the booleans, when we are defining a new operation on
datatypes we are allowed to assume some of the inputs are actually
values of the datatype.  Hence, we assume $[[n1]]$ and $[[n2]]$ are
actually peano numbers.  So they are $\lambda$-abstractions. Thus, the
definition of addition applies $[[n1]]$ to $[[s]]$ and $[[z]]$, which
results in a term identical to the peano numbers used in the previous
section, and then we use this term to replace the zero in $[[n2]]$.
Thus, obtaining a term with the correct number of successors.

Similarly, we can now use addition to define multiplication:
\[ [[mult]] := [[\n1.\n2.(h(n2 (plus n1) (\s.\z.z)))]]\] This definition
is identical to the definition we used in the previous section.

Finally, we can define exponentiation:
\[ [[exp]] := [[\n1.\n2.(h(n2 (mult n1) (\s.\z.(s z))))]] \]
% subsection peano_numbers_in_the_lam-calculus (end)

% section functions_are_numbers (end)


% \bibliographystyle{plain}
% \bibliography{thesis}
\end{document}
